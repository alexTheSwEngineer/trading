package com.traderepublic.atrposki.core.quotehistory;
/*
 * @author aleksandartrposki@gmail.com
 * @since 28.07.19
 *
 *
 */

import com.traderepublic.atrposki.core.hotstream.HotInstrumentController;
import com.traderepublic.atrposki.core.quotehistory.models.Candlestick;
import com.traderepublic.atrposki.core.quotehistory.models.PriceEventDTO;
import org.jooq.Record1;
import org.jooq.Record4;
import org.jooq.impl.DefaultDSLContext;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import static com.traderepublic.atrposki.autogenerated.jooq.partnereventstream.public_.tables.PriceEvent.PRICE_EVENT;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;
import static org.jooq.impl.DSL.max;
import static org.jooq.impl.DSL.min;

@Service
public class JooqQuoteService implements QuoteService {
    HotInstrumentController hotInstrumentEventPublisher;
    DefaultDSLContext db;

    public JooqQuoteService(HotInstrumentController hotInstrumentEventPublisher, DefaultDSLContext db) {
        this.hotInstrumentEventPublisher = hotInstrumentEventPublisher;
        this.db = db;
    }

    @Override
    public Map<Integer, PriceEventDTO> findByIdIn(Set<Integer> ids) {
        return db.select(PRICE_EVENT.ID, PRICE_EVENT.TIMESTAMP, PRICE_EVENT.PRICE, PRICE_EVENT.ISIN)
                .from(PRICE_EVENT)
                .where(PRICE_EVENT.ID.in(ids))
                .fetch().stream()
                .map(PriceEventDTO::fromRecord)
                .collect(toMap(PriceEventDTO::getId, identity()));
    }

    @Override
    public Optional<Candlestick> findLatestEventBefore(LocalDateTime lastSlot) {
        Record1<Integer> integerRecord1 = db.select(max(PRICE_EVENT.ID))
                .from(PRICE_EVENT)
                .where(PRICE_EVENT.TIMESTAMP.le(new Timestamp(lastSlot.getNano())))
                .fetchOne();

        return Optional.ofNullable(integerRecord1)
                .map(Record1::<Integer>value1)
                .map(this::findPriceEventById)
                .map(record -> new Candlestick());
    }

    @Override
    public Optional<PriceEventDTO> findPriceEventById(int id) {
        Record4<Integer, Timestamp, Double, String> priceEvent;
        priceEvent = db.select(PRICE_EVENT.ID, PRICE_EVENT.TIMESTAMP, PRICE_EVENT.PRICE, PRICE_EVENT.ISIN)
                .from(PRICE_EVENT)
                .where(PRICE_EVENT.ID.eq(id))
                .fetchOne();
        return Optional.ofNullable(priceEvent)
                .map(PriceEventDTO::fromRecord);
    }


    @Override
    public List<Candlestick> getCandlesticksWithoutOpenCloseIdsAfter(String isin, Timestamp timestamp) {
        return db.select(max(PRICE_EVENT.ID), min(PRICE_EVENT.ID), max(PRICE_EVENT.PRICE), min(PRICE_EVENT.PRICE), PRICE_EVENT.YEAR, PRICE_EVENT.MONTH, PRICE_EVENT.DAY, PRICE_EVENT.HOUR, PRICE_EVENT.MINUTE)
                .from(PRICE_EVENT)
                .where(PRICE_EVENT.TIMESTAMP.ge(timestamp)
                        .and(PRICE_EVENT.ISIN.eq(isin)))
                .groupBy(PRICE_EVENT.YEAR, PRICE_EVENT.MONTH, PRICE_EVENT.DAY, PRICE_EVENT.HOUR, PRICE_EVENT.MINUTE)
                .fetch()
                .stream()
                .map(Candlestick::fromRecordWithOpenCloseIds)
                .sorted(Candlestick.sortByDate)
                .collect(toList());
    }

    @Override
    public void saveEvent(PriceEventDTO priceEventDTO) {
        db.insertInto(PRICE_EVENT,
                PRICE_EVENT.ISIN,
                PRICE_EVENT.PRICE,
                PRICE_EVENT.TIMESTAMP,
                PRICE_EVENT.YEAR,
                PRICE_EVENT.MONTH,
                PRICE_EVENT.DAY,
                PRICE_EVENT.HOUR,
                PRICE_EVENT.MINUTE)
                .values(priceEventDTO.getIsin(),
                        priceEventDTO.getPrice(),
                        priceEventDTO.getTimestamp(),
                        priceEventDTO.getYear(),
                        priceEventDTO.getMonth(),
                        priceEventDTO.getDay(),
                        priceEventDTO.getHour(),
                        priceEventDTO.getMinute())
                .execute();
    }
}
